package imp

import (
	"context"
	"sync"
)

// 이건 따로 떼어 놓는 것보다. 그냥 factor 에 넣어 두어야 하는게 맞을 듯하다.

type FactoryInMem struct {
	mu       sync.RWMutex
	reg      map[string]*SpawnActor
	mkDriver func(key string) driver.Driver
	mbSize   int
}

func NewFactoryInMem(mkDrv func(string) driver.Driver, mbSize int) *FactoryInMem {
	return &FactoryInMem{
		reg:      map[string]*SpawnActor{},
		mkDriver: mkDrv, mbSize: mbSize}
}

func (f *FactoryInMem) GetOrCreate(spawnKey string) (Actor, bool, error) {
	f.mu.RLock()
	if a, ok := f.reg[spawnKey]; ok {
		f.mu.RUnlock()
		return a, false, nil
	}
	f.mu.RUnlock()

	f.mu.Lock()
	defer f.mu.Unlock()
	if a, ok := f.reg[spawnKey]; ok {
		return a, false, nil
	}

	drv := f.mkDriver(spawnKey)
	a := NewSpawnActor(spawnKey, drv, f.mbSize)
	f.reg[spawnKey] = a

	// start loop
	go a.Loop(context.Background())
	return a, true, nil
}
